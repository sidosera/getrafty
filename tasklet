#!/bin/sh
set -e

CONTAINER_NAME="getrafty"
CONTAINER_USER="ubuntu"
CONTAINER_BIND_DIR="$(pwd)"
CONTAINER_SSH_PORT=3333
CONTAINER_SITE_PORT=3000
CONTAINER_FILE_PORT=8000
R='\033[31m'
G='\033[32m'
Y='\033[33m'
C='\033[36m'
M='\033[35m'
B='\033[1m'
N='\033[0m'

info() { printf "${C}>${N} %s\n" "$1"; }
ok() { printf "${G}OK${N} %s\n" "$1"; }
fail() { printf "${R}FAIL${N} %s\n" "$1" >&2; }
warn() { printf "${Y}WARN${N} %s\n" "$1"; }

die() {
    fail "$1"
    exit 1
}

check_docker() {
    command -v docker >/dev/null 2>&1 || die "docker not found"
}

check_yq() {
    command -v yq >/dev/null 2>&1 || die "yq not found"
}

check_container_exists() {
    docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null
}

check_container_is_running() {
    docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null
}

remove_existing_container() {
    container_id=$(check_container_exists)
    if [ -n "$container_id" ]; then
        printf "Removing existing container %s...\n" "$container_id"
        docker rm -f "$container_id" >/dev/null
    fi
}

restart_existing_container() {
    container_id=$(check_container_exists)
    if [ -n "$container_id" ]; then
        printf "Found existing container %s. Restarting it...\n" "$container_id"
        if docker start "$container_id" >/dev/null 2>&1; then
            return 0
        else
            warn "Failed to restart container (likely networking issue). Removing and recreating..."
            docker rm -f "$container_id" >/dev/null 2>&1
            return 1
        fi
    fi
    return 1
}

confirm() {
    printf "%s [y/N] " "$1"
    read -r response
    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        *) return 1 ;;
    esac
}

cfg() {
    d="$1"
    key="$2"
    if [ -f "$d/task.yaml" ]; then
        yq eval ".$key // \"\"" "$d/task.yaml" 2>/dev/null | grep -v '^null$' || echo ""
    else
        echo ""
    fi
}

get_profiles() {
    [ -f "cmake-variants.yaml" ] || die "cmake-variants.yaml not found"
    yq eval '.buildType.choices | keys | .[]' cmake-variants.yaml 2>/dev/null
}

get_tests() {
    d="$1"
    if [ -f "$d/task.yaml" ]; then
        yq eval '.tests[]? // ""' "$d/task.yaml" 2>/dev/null | grep -v '^null$' || cfg "$d" "tests"
    else
        cfg "$d" "tests"
    fi
}

expand() {
    result="$1"
    shift
    while [ $# -gt 0 ]; do
        result=$(echo "$result" | sed "s|{{$1}}|$2|g")
        shift 2
    done
    echo "$result"
}

runcmd() {
    d="$1"
    cmd="$2"
    shift 2

    template=$(cfg "$d" "commands.$cmd")
    [ -z "$template" ] && template=$(cfg "$d" "command.$cmd")

    # Convention over configuration defaults
    if [ -z "$template" ]; then
        case "$cmd" in
            configure)
                template='cmake -S {{project_root}} -B {{build_dir}} -DCMAKE_C_COMPILER={{c_compiler}} -DCMAKE_CXX_COMPILER={{cxx_compiler}} {{flags}}'
                ;;
            build)
                template='cmake --build {{build_dir}} --target {{target}} -j$(nproc)'
                ;;
            run)
                template='{{binary_path}}'
                ;;
            clean)
                template='rm -rf {{build_dir}}'
                ;;
        esac
    fi

    eval "$(expand "$template" "$@")"
}

build_profile() {
    d="tasks/$1"
    p="$2"

    info "build $1 [$p]"

    cc=$(cfg "$d" "compiler.c")
    [ -z "$cc" ] && cc=$(cfg "$d" "cmake.c_compiler")
    [ -z "$cc" ] && cc="clang"

    cxx=$(cfg "$d" "compiler.cxx")
    [ -z "$cxx" ] && cxx=$(cfg "$d" "cmake.cxx_compiler")
    [ -z "$cxx" ] && cxx="clang++"

    bdir="build"

    btype=$(yq eval ".buildType.choices.$p.buildType" cmake-variants.yaml 2>/dev/null)
    [ -z "$btype" ] && btype="Debug"

    flags="-DCMAKE_BUILD_TYPE=$btype"
    for key in $(yq eval ".buildType.choices.$p.settings | keys | .[]" cmake-variants.yaml 2>/dev/null); do
        val=$(yq eval ".buildType.choices.$p.settings.$key" cmake-variants.yaml 2>/dev/null)
        if [ -n "$val" ]; then
            flags="$flags -D$key=$val"
        fi
    done

    root="$(pwd)"

    # Remove CMake cache to avoid conflicts between different build profiles
    [ -f "$bdir/CMakeCache.txt" ] && rm -f "$bdir/CMakeCache.txt"

    out=$(runcmd "$d" "configure" \
        "c_compiler" "$cc" \
        "cxx_compiler" "$cxx" \
        "flags" "$flags" \
        "root" "$root" \
        "project_root" "$root" \
        "build_dir" "$bdir" 2>&1) || {
        fail "configure failed"
        printf "%s\n" "$out" >&2
        return 1
    }

    for t in $(get_tests "$d"); do
        out=$(runcmd "$d" "build" "build_dir" "$bdir" "target" "$t" 2>&1) || {
            fail "build $t failed"
            printf "%s\n" "$out" >&2
            return 1
        }
    done

    ok "build $1 [$p]"
}

run_profile_tests() {
    d="tasks/$1"
    p="$2"

    info "test $1 [$p]"

    tpl=$(cfg "$d" "binary_path")
    bdir="build"
    fail_cnt=0

    for t in $(get_tests "$d"); do
        bin=$(expand "$tpl" "build_dir" "$bdir" "task" "$1" "binary" "$t")
        [ -f "$bin" ] || {
            warn "$t: not found"
            continue
        }

        # Set coverage output location if in Debug mode
        test_name=$(basename "$bin")
        export LLVM_PROFILE_FILE="${bdir}/coverage/${test_name}-%p.profraw"

        out=$(runcmd "$d" "run" "binary_path" "$bin" "binary" "$bin" 2>&1)
        if [ $? -eq 0 ]; then
            ok "$t"
        else
            fail "$t"
            printf "%s\n" "$out" >&2
            fail_cnt=$((fail_cnt + 1))
        fi
    done

    [ $fail_cnt -eq 0 ]
}

cmd_boot() {
    build_flag=0
    if [ "$1" = "--build" ]; then
        build_flag=1
    fi

    check_docker

    if [ $build_flag -eq 1 ]; then
        if [ -n "$(check_container_is_running)" ]; then
            if confirm "The container is running. Do you want to stop and rebuild it?"; then
                remove_existing_container
            else
                printf "Exiting without rebuilding.\n"
                return 0
            fi
        else
            remove_existing_container
        fi

        image_id=$(docker images "$CONTAINER_NAME" -q)
        if [ -n "$image_id" ]; then
            docker rmi "$image_id" >/dev/null
        fi
        docker build -t "$CONTAINER_NAME" .
    else
        if [ -n "$(check_container_is_running)" ]; then
            printf "Container is up. Connect by running: \`tasklet attach\`.\n"
            return 0
        fi

        if restart_existing_container; then
            printf "Container restarted successfully. Connect by running: \`tasklet attach\`.\n"
            return 0
        fi
    fi

    docker run -d \
        --name "$CONTAINER_NAME" \
        --cap-add SYS_PTRACE \
        --cap-add SYS_ADMIN \
        --privileged \
        -v "${CONTAINER_BIND_DIR}:/home/${CONTAINER_USER}/workspace/" \
        -p "${CONTAINER_SSH_PORT}:22" \
        -p "${CONTAINER_SITE_PORT}:${CONTAINER_SITE_PORT}" \
        -p "${CONTAINER_FILE_PORT}:${CONTAINER_FILE_PORT}" \
        "$CONTAINER_NAME" >/dev/null

    printf "Connect by running: \`tasklet attach\`.\n"
    printf "File server available at http://localhost:%s/\n" "${CONTAINER_FILE_PORT}"
}

cmd_attach() {
    root_flag=0
    if [ "$1" = "--root" ]; then
        root_flag=1
    fi

    container_id=$(check_container_is_running)
    if [ -z "$container_id" ]; then
        die "DevVM is not running."
    fi

    if [ $root_flag -eq 1 ]; then
        docker exec -it "$container_id" /bin/bash
    else
        host_ip=$(hostname -i 2>/dev/null | awk '{print $1}')
        if [ -z "$host_ip" ]; then
            host_ip=$(ifconfig 2>/dev/null | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1)
        fi
        ssh "${CONTAINER_USER}@${host_ip}" -p "$CONTAINER_SSH_PORT"
    fi
}

cmd_restart() {
    check_docker

    container_id=$(check_container_exists)
    if [ -z "$container_id" ]; then
        die "Container does not exist. Run 'tasklet boot' first."
    fi

    printf "Restarting container %s...\n" "$container_id"
    if docker restart "$container_id" >/dev/null 2>&1; then
        printf "Container restarted successfully. Connect by running: \`tasklet attach\`.\n"
    else
        warn "Failed to restart container. Try 'tasklet boot' to recreate it."
        return 1
    fi
}

cmd_test() {
    if [ "$(whoami)" != "$CONTAINER_USER" ] && [ -n "${CONTAINER_NAME:-}" ]; then
        c=$(check_container_is_running)
        [ -z "$c" ] && die "container not running"
        docker exec -u "$CONTAINER_USER" -w /home/$CONTAINER_USER/workspace "$c" ./tasklet test "$@"
        return $?
    fi

    [ -z "$1" ] && die "task name required"
    d="tasks/$1"
    [ -d "$d" ] || die "task not found: $1"

    fail_cnt=0
    for p in $(get_profiles "$d"); do
        build_profile "$1" "$p" || { fail_cnt=$((fail_cnt + 1)); continue; }
        run_profile_tests "$1" "$p" || fail_cnt=$((fail_cnt + 1))
    done

    [ $fail_cnt -eq 0 ] && { ok "all tests passed"; exit 0; }
    fail "$fail_cnt profile(s) failed"
    exit 1
}


cmd_clean() {
    if [ "$(whoami)" != "$CONTAINER_USER" ] && [ -n "${CONTAINER_NAME:-}" ]; then
        c=$(check_container_is_running)
        [ -z "$c" ] && die "container not running"
        docker exec -u "$CONTAINER_USER" -w /home/$CONTAINER_USER/workspace "$c" ./tasklet clean "$@"
        return $?
    fi

    [ -z "$1" ] && die "task name required"
    d="tasks/$1"
    [ -d "$d" ] || die "task not found: $1"

    bdir="build"
    [ -d "$bdir" ] && runcmd "$d" "clean" "build_dir" "$bdir"

    ok "clean done"
}

cmd_list() {
    for d in tasks/*; do
        [ -d "$d" ] || continue
        [ -f "$d/task.yaml" ] || continue
        name=$(basename "$d")
        desc=$(cfg "$d" "description")
        printf "%s: %s\n" "$name" "$desc"
    done
}

cmd_coverage() {
    if [ "$(whoami)" != "$CONTAINER_USER" ] && [ -n "${CONTAINER_NAME:-}" ]; then
        c=$(check_container_is_running)
        [ -z "$c" ] && die "container not running"
        docker exec -u "$CONTAINER_USER" -w /home/$CONTAINER_USER/workspace "$c" ./tasklet coverage "$@"
        return $?
    fi

    [ -z "$1" ] && die "task name required"
    d="tasks/$1"
    [ -d "$d" ] || die "task not found: $1"

    # Build in Debug mode with coverage
    p="Debug"
    info "coverage $1 [$p]"

    build_profile "$1" "$p" || die "build failed"

    # Run tests with coverage collection
    run_profile_tests "$1" "$p" || die "tests failed"

    # Generate coverage report
    bdir="build"
    coverage_script="${bdir}/create-coverage-report.sh"
    [ -f "$coverage_script" ] || die "coverage script not found"

    "$coverage_script" || die "coverage generation failed"
    ok "coverage $1 [$p]"
}

usage() {
    cat <<EOF
usage: tasklet <command> [options]

container:
  boot [--build]    start dev container
  attach [--root]   attach to container
  restart           restart container

tasks:
  test <task>       run all tests
  clean <task>      clean build artifacts
  coverage <task>   run tests and generate coverage report
  list              list tasks
EOF
}

case "${1:-}" in
    boot)
        shift
        cmd_boot "$@"
        ;;
    attach)
        shift
        cmd_attach "$@"
        ;;
    restart)
        shift
        cmd_restart "$@"
        ;;
    test)
        shift
        cmd_test "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    coverage)
        shift
        cmd_coverage "$@"
        ;;
    list)
        cmd_list
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        printf "Error: Unknown command '%s'\n\n" "$1" >&2
        usage
        exit 1
        ;;
esac
